<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on compgen.io</title>
    <link>http://compgen.io/tutorials/</link>
    <description>Recent content in Tutorials on compgen.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Dec 2015 00:54:57 -0500</lastBuildDate>
    <atom:link href="http://compgen.io/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>FASTQ Pre-processing</title>
      <link>http://compgen.io/tutorials/fastq-preprocessing/</link>
      <pubDate>Tue, 15 Dec 2015 00:54:57 -0500</pubDate>
      
      <guid>http://compgen.io/tutorials/fastq-preprocessing/</guid>
      <description>

&lt;p&gt;The first step in NGS analysis is pre-processing your &lt;a href=&#34;http://compgen.io/tutorials/formats#fastq&#34;&gt;FASTQ&lt;/a&gt; files. The
following tutorial uses &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-filter&#34;&gt;ngsutilsj fastq-filter&lt;/a&gt; to process and filter FASTQ
files.&lt;/p&gt;

&lt;h2 id=&#34;sequence-qc-tools:7c1c16d52a003e021a2f64f3832428af&#34;&gt;Sequence QC tools&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s important to measure certain quality control metrics with FASTQ files.
You should run the same QC checks against the files before and after pre-
processing. This will help you assess the quality of your data and measure
how well the pre-processing is working. QC monitoring is a critical part of NGS
analysis that is often neglected. Without monitoring read QC, you may inadvertently
use low-quality data, which could produce invalid analysis. (and a lot of wasted effort!)&lt;/p&gt;

&lt;h3 id=&#34;fastqc:7c1c16d52a003e021a2f64f3832428af&#34;&gt;FastQC&lt;/h3&gt;

&lt;p&gt;One commonly used program to assess the quality of FASTQ data is &lt;a href=&#34;http://www.bioinformatics.babraham.ac.uk/projects/fastqc/&#34;&gt;FastQC&lt;/a&gt;.
FastQC is a good tool for assessing the initial quality of FASTQ reads and provides a number
of quality control metrics, including per-base sequence quality, GC %, per-base
call frequency, over-represented sequences, and adapter content. The final report
from FastQC can be saves as a ZIP or HTML report for use in pipelines. However,
FastQC can take a while to run on larger files.&lt;/p&gt;

&lt;h3 id=&#34;ngsutilsj-fastq-stats:7c1c16d52a003e021a2f64f3832428af&#34;&gt;ngsutilsj fastq-stats&lt;/h3&gt;

&lt;p&gt;For high-throughput streaming workflows, where the FASTQ data is processed on-the-fly,
it may not be possible (or practical) to save a copy of the data. In this case, you need a tool that
can calculate QC metrics for FASTQ data that is streamed as part of a stdin/stdout pipeline. &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt;
supports this method and calculates per-base sequence quality, GC %, per-base call
frequencgy, and adapter content. Additionally, &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt; also support interleaved FASTQ
files and reporting first/second read stats separately. The final report from &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt; is
a raw text file that requires further processing to produce figures.&lt;/p&gt;

&lt;p&gt;Importantly, when inserted into a FASTQ pipeline, &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt; requires no extra
processing time, and minimal memory/CPU resources.&lt;/p&gt;

&lt;h2 id=&#34;dna-seq-filtering-methods:7c1c16d52a003e021a2f64f3832428af&#34;&gt;DNA-seq filtering methods&lt;/h2&gt;

&lt;p&gt;Pre-processing DNA-seq files is more straightforward than RNA-seq, so we&amp;rsquo;ll
start there. For DNA-seq, the primary concern is removing low-quality bases
and reads before sending them through the computationally intensive alignment
process. The more that we clean up the data before alignment, the better the
aligned data will be.&lt;/p&gt;

&lt;p&gt;Here are some of the ways to cleanup FASTQ reads with &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-filter&#34;&gt;ngsutilsj fastq-filter&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Remove reads based on a name white/black list
If you have a specific list of reads to keep or drop, they can be passed as a &lt;code&gt;--whitelist&lt;/code&gt;
or &lt;code&gt;--blacklist&lt;/code&gt; respectively.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fixed base count 5&amp;rsquo;/3&amp;rsquo; trim&lt;br /&gt;
You can remove a fixed number of bases from the 5&amp;rsquo; or 3&amp;rsquo; ends of a read
with the &lt;code&gt;--prefixtrim&lt;/code&gt; or &lt;code&gt;--suffixtrim&lt;/code&gt; options.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Remove low quality bases from the 5&amp;rsquo; and 3&amp;rsquo; ends&lt;br /&gt;
It is common for there to be stretches of low-quality base calls at the 3&amp;rsquo;
end of a read. It is less common to see low-quality calls at the 5&amp;rsquo; end. You
can set a fixed threshold for minimum call quality at the 5&amp;rsquo; or 3&amp;rsquo; ends using the
&lt;code&gt;--prefixqual&lt;/code&gt; and &lt;code&gt;--suffixqual&lt;/code&gt; options. For example, if the threshold is set at
3, then any base with a Phred quality score less than 3 will be removed from the
ends of the reads.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trim adapter sequences&lt;br /&gt;
If the fragment being sequenced is shorter than the read length, you will see adapter
sequences as part of the read sequence. Because these are artifacts of the sequencing
reaction and not part of the organism, it is important to remove these sequences. There are
three options for removing adapters: &lt;code&gt;--trim-seq&lt;/code&gt;, &lt;code&gt;--trim-seq1&lt;/code&gt;, &lt;code&gt;--trim-seq2&lt;/code&gt;. The
first option trims an adapter from all sequences in a file. The second and third options
trim the adapter from the first and second reads, respectively (assuming an interleaved
FASTQ file). If you have a non-interleaved file, then &lt;code&gt;--trim-seq&lt;/code&gt; and &lt;code&gt;--trim-seq1&lt;/code&gt; are
equivalent.  As extra options for adapter trimming: &lt;code&gt;--trim-pct&lt;/code&gt; sets the required match
percentage a the read has to have to match the adapter. The default is 0.9, or 9 out of
10 bases must match. The second option is &lt;code&gt;--trim-overlap&lt;/code&gt;, which sets the minimum amount
of sequence must match at the 3&amp;rsquo; end of the read to trigger trimming. The default value
is 6 bases.&lt;br /&gt;
&lt;br/&gt;
Note: adapter trimming is done using a sliding window, so it is necessarily computationally
intensive. It should only be done when you really need to do it.&lt;br /&gt;
&lt;br/&gt;
For Illumina sequencing, the recommended adapter trimming sequences can be set using the
&lt;code&gt;--trim-illumina&lt;/code&gt; option. These sequences are read-specific and are shown below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;read1: AGATCGGAAGAGCACACGTC&lt;/li&gt;
&lt;li&gt;read2: AGATCGGAAGAGCGTCGTGT&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Limit abiguous/wildcard (N) bases&lt;br /&gt;
Reads with too many &lt;em&gt;N&lt;/em&gt; calls can be removed using the &lt;code&gt;--wildcard&lt;/code&gt; option.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Size selection
After all of the above trimming, the final read filter can require a certain minimum read length
with the &lt;code&gt;--size&lt;/code&gt; option.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Required valid paired reads (requires interleaved FASTQ file)
If you have an interleaved FASTQ file, you can use the &lt;code&gt;--paired&lt;/code&gt; option to require that both
reads from a fragment need to pass the filters. Otherwise, you can end up with an unbalanced FASTQ
file, which can lead to unpredictable results in the downstream analysis. However, this option
is only available when using an interleaved FASTQ file. Processing two separate files and trying
to merge them after the fact is computationally difficult and may require a lot of memory to resolve
mismatches between the files.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note: filters are applied in the above order, so that (for example) low-quality bases at the 5&amp;rsquo;/3&amp;rsquo; ends can be
trimmed away before triggering the ambiguous base call filters.&lt;/p&gt;

&lt;h3 id=&#34;examples:7c1c16d52a003e021a2f64f3832428af&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Here is one way to filter a single-end FASTQ file, or a split paired-end (not interleaved) file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# trim 3&#39; low-quality bases
# remove reads with more than 2 N&#39;s
# require the final size to be at least 50bp

ngsutilsj fastq-filter --size 50 --wildcard 2 --suffixqual 3 input.fastq.gz &amp;gt; filtered.fastq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Here is a more complete set of filters, including a merging step to combine paired-end
files into one interleaved FASTQ file first.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# trim 3&#39; low-quality bases
# remove illumina adapters
# remove reads with more than 2 N&#39;s
# require the final size to be at least 50bp
# require reads to be properly paired

ngsutilsj fastq-merge input_R1.fastq.gz input_R2.fastq.gz | \
ngsutilsj fastq-filter --size 50 --wildcard 2 --suffixqual 3 --trim-illumina --paired - | \
gzip &amp;gt; filtered.fastq.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Finally, we can add &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt; into the mix to calculate some
summary statistics on the fly for both the raw FASTQ reads and the post-filtering reads.
By merging the paired FASTQ files and using &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt;,
we can efficiently pre-process the FASTQ reads in one pipeline and limit unnecessary disk I/O.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngsutilsj fastq-merge input_R1.fastq.gz input_R2.fastq.gz | \
ngsutilsj fastq-stats --pipe -o raw.stats.txt - | \
ngsutilsj fastq-filter --size 50 --wildcard 2 --suffixqual 3 --trim-illumina --paired - | \
ngsutilsj fastq-stats --pipe -o filtered.stats.txt - | \
gzip &amp;gt; filtered.fastq.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
As shown above and following *nix conventions, many of the &lt;a href=&#34;http://compgen.io/ngsutilsj&#34;&gt;ngsutilsj&lt;/a&gt; tools can
operate in streaming mode by specifying &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; as the input filename, reading input from &lt;em&gt;stdin&lt;/em&gt;. &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-stats&#34;&gt;ngsutilsj fastq-stats&lt;/a&gt;
can be coerced into passing the incoming FASTQ data through to &lt;em&gt;stdout&lt;/em&gt; with the &lt;code&gt;--pipe&lt;/code&gt; option.&lt;/p&gt;

&lt;h2 id=&#34;rna-seq-filtering-methods:7c1c16d52a003e021a2f64f3832428af&#34;&gt;RNA-seq filtering methods&lt;/h2&gt;

&lt;p&gt;Pre-processing RNA-seq data can be done in the same manner as DNA-seq data, with the same general
options. But, with RNA-seq data, there is another filtering step that you should consider:
ribosomal sequence filtering. A good library prep will remove the majority of rRNA sequences
before they are sequenced. If this depletion fails, then many of reads will be from
rRNAs. This makes tracking the abundance of rRNAs an important QC metric to ensure consistent
data.&lt;/p&gt;

&lt;p&gt;Filtering out rRNA reads is covered in-depth in the &lt;a href=&#34;http://compgen.io/tutorials/rnaseq-star&#34;&gt;RNA-Seq workflow&lt;/a&gt; tutorial.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>File formats</title>
      <link>http://compgen.io/tutorials/formats/</link>
      <pubDate>Tue, 15 Dec 2015 00:54:57 -0500</pubDate>
      
      <guid>http://compgen.io/tutorials/formats/</guid>
      <description>

&lt;h2 id=&#34;sequencing-formats:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Sequencing formats&lt;/h2&gt;

&lt;p&gt;&lt;a name=&#34;fasta&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;fasta-tutorials-formats-fasta:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;FASTA &lt;a href=&#34;http://compgen.io/tutorials/formats#fasta&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;FASTA files are the de-facto standard for storing and sharing DNA/RNA/amino acid
sequences. It is a text-file format with a header line followed by one or more lines of sequence.
The header line starts with a &amp;lsquo;&amp;gt;&amp;rsquo; character, which may be used for parsing the file. The remainder
of the header line consists of a name, optionally followed by a comment. The name and comment are
separated by whitespace. The name must not contain a whitespace (&lt;code&gt;Â &lt;/code&gt;, or &lt;code&gt;\t&lt;/code&gt;) character.&lt;/p&gt;

&lt;p&gt;The remaining lines consist of DNA, RNA, or amino acid sequences using IUPAC notation. There are no
technical specifications for line length or wrapping, but it is common practice for long sequences
(genes/genomes) to be have a consistent line length. However, it is not required for the sequence to have
any breaks. Blank lines and any whitespace in the sequence line(s) should be ignored.&lt;/p&gt;

&lt;p&gt;FASTA is the most common format for distributing reference genome sequences. Reference genomes will
contain one sequence for each chromosome. In addition to chromosomes, some reference genomes will
also include unplaced contigs, which are sequences known to be part of the organism&amp;rsquo;s genome, but
the exact position is unclear.&lt;/p&gt;

&lt;h4 id=&#34;variations:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Variations&lt;/h4&gt;

&lt;p&gt;FASTA files are commonly stored as &lt;code&gt;gzip&lt;/code&gt; compressed files, due to their large size and general space inefficiency. However,
files that need to be randomly accessed need to be stored uncompressed, or compressed with a tool like &lt;code&gt;bgzip&lt;/code&gt; (although the
latter is less common).&lt;/p&gt;

&lt;h4 id=&#34;example:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;sequence1 This is the comment line
ATCGATCGATCGACTACGACTACGACGACGACATCGACATCTACT
GGCGCGCGCTAGAGCTAGCTTGAGATAAATCGACTAGCGACTGAG
CTATCTTCTCTATATATTTAAAAAGCGCAACTACTGACTA
&amp;gt;seq2
AATAGCGCGCGCGCGCTCATATATCTATATATAAAAACCTACTAC
GACTACGACTATCGATCGATTATCGGTATCGTATCGGTATTATTA
TTTAATGCGCGCGCGCCGACTAGCTAGCTATCGATCGATCGATCG
ACTACGACTACGACGACGACATCGACATCTACT
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;tools:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Tools&lt;/h4&gt;

&lt;p&gt;FASTA files can be indexed and queried with the program &lt;code&gt;samtools faidx&lt;/code&gt;. This requires a well-formatted FASTA file with
consistent line lengths.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://compgen.io/ngsutilsj&#34;&gt;ngsutilsj&lt;/a&gt; contains a number of tools for managing FASTA files, including indexed FASTA files. These tools
including tagging sequence names, masking regions of sequences, splitting a FASTA file by sequence name, changing the
line wrapping for a file, or generating mock &lt;a href=&#34;http://compgen.io/tutorials/formats#fastq&#34;&gt;FASTQ&lt;/a&gt; reads.&lt;/p&gt;

&lt;h4 id=&#34;external-links:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;External links&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/FASTA_format&#34;&gt;https://en.wikipedia.org/wiki/FASTA_format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;fastq&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;fastq-tutorials-formats-fastq:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;FASTQ &lt;a href=&#34;http://compgen.io/tutorials/formats#fastq&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;FASTQ is the most common sequencing read format. FASTQ files are text files with a four-line record
for each sequence. The first line starts with an &amp;lsquo;@&amp;rsquo; character and the unique name for the read. The
second line is the sequence. The third line starts with the &amp;lsquo;+&amp;rsquo; character, and may optionally contain
the read name again. The fourth line is the quality score for each of the basecalls in &lt;a href=&#34;https://en.wikipedia.org/wiki/Phred_quality_score&#34;&gt;Phred&lt;/a&gt; scale.&lt;/p&gt;

&lt;h4 id=&#34;variations-1:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Variations&lt;/h4&gt;

&lt;p&gt;The sequence and quality lines in the FASTQ record may be word-wrapped, like FASTA files, but this is not seen very often.&lt;/p&gt;

&lt;p&gt;FASTQ files are almost always stored compressed, usually with &lt;code&gt;gzip&lt;/code&gt;, although &lt;code&gt;bzip2&lt;/code&gt; compression is sometimes
also used. FASTQ record information can also be stored in other compressed formats, such as &lt;a href=&#34;http://compgen.io/tutorials/formats#unalignedbam&#34;&gt;unaligned BAM&lt;/a&gt; files
or &lt;a href=&#34;http://compgen.io/tutorials/formats#sqz&#34;&gt;SQZ&lt;/a&gt; files. However, almost all publicly available data is distributed as gzip-compressed
FASTQ files.&lt;/p&gt;

&lt;p&gt;Paired-end sequencing data is commonly stored as two separate FASTQ files, one for each read. But, it is also possible
to store both reads in the same file. These are called &lt;em&gt;interleaved&lt;/em&gt; FASTQ files. Many aligners support interleaved
files out of the box for paired end data. For those that don&amp;rsquo;t an adapter tool can be used to convert interleaved files
to non-interleaved files using named FIFO pipes. Interleaved FASTQ files are slightly have slightly more efficient
compression ratios when compared to using two separate FASTQ files, but the main benefit is the need to only manage
one file per sample. Interleaved files can also be easier to filter using a tool like &lt;a href=&#34;http://compgen.io/ngsutilsj/fastq-filter&#34;&gt;ngsutilsj fastq-filter&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;example-1:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;@seq1 This is the comment line
ATCGATCGATCGACTACGACTACGACGACGACATCGACATCTACT
+
BBBB,(,,7AA,&amp;lt;((,A&amp;lt;,,,FKAF,,,F,F7F,7,,,AA##@!@
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;external-links-1:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;External links&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/FASTQ_format&#34;&gt;https://en.wikipedia.org/wiki/FASTQ_format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;unalignedbam&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;unaligned-bam-file-tutorials-formats-fastq:e863fee43a2d970cdaf6bcd21442137d&#34;&gt;Unaligned BAM file &lt;a href=&#34;http://compgen.io/tutorials/formats#fastq&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;BAM files are typically associated with read alignments to a genome, but they can also be used to store unaligned/raw
sequences too. Unaligned BAM files store the same read information as a FASTQ file (name, sequence, and
quality scores) and they can also store multiple reads in the same file (like interleaved FASTQ files). Also,
unaligned BAM files are compressed, and store quality score information in an optimized manner versus character
encoding. Even with the extra overhead of the BAM format, these factors make this a slightly more efficient way
to store raw sequencing reads over FASTQ files.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RNA-Seq workflow (with STAR)</title>
      <link>http://compgen.io/tutorials/rnaseq-star/</link>
      <pubDate>Tue, 15 Dec 2015 00:54:57 -0500</pubDate>
      
      <guid>http://compgen.io/tutorials/rnaseq-star/</guid>
      <description>

&lt;h2 id=&#34;experimental-design:84023ea70f860fd54a3045c7b4b6259f&#34;&gt;Experimental design&lt;/h2&gt;

&lt;p&gt;The first step in getting good results from an RNA-Seq experiment is choosing a good experimental
design. This means that you need to have enough replicates, with sufficient sequencing depth to
be able to answer your research question.&lt;/p&gt;

&lt;h3 id=&#34;depth:84023ea70f860fd54a3045c7b4b6259f&#34;&gt;Depth&lt;/h3&gt;

&lt;p&gt;For differential gene expression, I recommend having at least 4 biological replicates for each
condition with a minimum of 20M reads per sample (30M recommended). Additionally, we&amp;rsquo;ve found that pair-end sequencing
produces more uniquely aligned reads than single-end sequencing. If you want to investigate
changes in splicing, I recommend at least 40M reads per sample (50M recommended).&lt;/p&gt;

&lt;h3 id=&#34;batch-effects:84023ea70f860fd54a3045c7b4b6259f&#34;&gt;Batch effects&lt;/h3&gt;

&lt;p&gt;Additionally, you need to try to reduce any possible batch effects in your data. One common batch
effect is due to a lane-effect present when samples are sequenced only on a single lane. If your
control and experimental samples are sequenced on different lanes, there is no way to differentiate
between a lane-effect and biological signal. A different experimental design can be used to avoid
batch effects by pooling (and barcoding) all of your samples together. Then you can sequence that
pool as many times as necessary to get the required sequencing depth. So, for example, if you require
two lanes worth of data, you would sequence all samples across all lanes.&lt;/p&gt;

&lt;h2 id=&#34;pre-processing:84023ea70f860fd54a3045c7b4b6259f&#34;&gt;Pre-processing&lt;/h2&gt;

&lt;p&gt;RNA-Seq reads should undergo the same pre-processing/QC filtering steps that you&amp;rsquo;d use in DNA-Seq.&lt;/p&gt;

&lt;p&gt;It is almost more important to measure and track QC metrics with RNA-Seq data than with DNA-Seq.
Because RNA-Seq is most commonly used for gene expression analysis, it is important to make sure that
each same has a similar QC profile. It isn&amp;rsquo;t necessarily important to hit exact
QC benchmarks, but rather it is more important to make sure that all samples have a &lt;em&gt;similar&lt;/em&gt; profile.
If one of your samples has vastly more rRNA or many more adapter truncted sequences, this could affect
your downstream analysis. If all of the samples have a similar profile, then you can be more confident
that your results are due to biological differences, not technical differences.&lt;/p&gt;

&lt;h2 id=&#34;ribosomal-rna-filtering:84023ea70f860fd54a3045c7b4b6259f&#34;&gt;Ribosomal RNA filtering&lt;/h2&gt;

&lt;p&gt;Ribosomal RNA is always a concern with RNA-Seq. rRNA is vastly more abundant in total RNA extractions
than mRNA or other non-coding RNAs. Because of this, it is sometimes useful to remove rRNA sequences
before mapping the remaining reads. Even if you don&amp;rsquo;t filter out rRNA reads, it is a useful QC
metric to observe and track.&lt;/p&gt;

&lt;p&gt;rRNA filtering can be done using an rRNA reference index and an alignment tool like &lt;code&gt;bwa&lt;/code&gt;. &lt;code&gt;bwa&lt;/code&gt; is
used instead of an RNA-specific aligner because we don&amp;rsquo;t need to keep track of splicing in this
step.  The source of a good rRNA reference varys based on the organism, but possible sources
include searching NCBI Genbank for molecules of the type &lt;em&gt;rRNA&lt;/em&gt;, species-specific rRNA databases,
or pulling ribosomal regions from references genomes using RepeatMasker.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>